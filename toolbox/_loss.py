#!/usr/bin/env python
# -*- coding: utf-8 -*-
from abc import ABCMeta, abstractmethod
import numpy as np
import torch
import torch.nn.functional as F
from torch.nn.modules.loss import _Loss


class StatLoss(_Loss, metaclass=ABCMeta):
    '''Base class for all statistic-based loss functions. This is an abstract
    class because it only handles the processing for the 'target' properties,
    and leaves the definition of actual comparison operations to concrete
    subclasses.
    '''

    @classmethod
    def from_expr(cls, expr, t, **options):
        '''Specify the target statistic function with an expression
        at given evaluation points.

        Parameters
        ----------
        expr: callable
            A function to be evaluated at the given points.
        t: list-like
            A list of uniformly spaced grid points on which the expression will
            be evaluated.
        options: keyword argument list
            To be forwarded to `__init__`.
        '''
        return cls(np.fromiter(map(expr, t), dtype=np.float32), **options)

    def __init__(self, target, pointwise_loss='mse_loss', device='cpu',
                 **kwargs):
        '''Direct specification of the target statistic function in discretized
        form.

        Parameters
        ----------
        array: list-like The target statistic function.
        '''
        super().__init__()
        self._target = torch.tensor(target, dtype=torch.float32, device=device)
        if callable(pointwise_loss):
            self._loss = pointwise_loss
        else:
            try:
                self._loss = getattr(F, pointwise_loss)
            except AttributeError as e:
                raise RuntimeError(f'Unrecognized pointwise loss. Error:\n{e}')
        self.__dict__.update(**kwargs)

    @staticmethod
    def acf(x, lags=None, method='fft'):
        x = x - x.mean()
        if method == 'fft':
            f = torch.fft.fft(x, x.shape[0] * 2 - 1, dim=0)
            acf = torch.fft.ifft(
                f * f.conj(), dim=0
            ).real[
                :x.shape[0]
            ].mean(axis=1)
            return acf[:lags, ...] / acf[0, ...]
        elif method == 'bruteforce':
            if lags is None:
                lags = torch.arange(x.shape[0])
            elif isinstance(lags, int):
                lags = torch.arange(lags)
            else:
                lags = torch.tensor(lags, dtype=torch.int32)
            corr = torch.zeros((len(lags), *x.shape[2:]), device=x.device)
            for i, lag in enumerate(lags):
                if lag == 0:
                    u = v = x
                elif lag < x.shape[0]:
                    u, v = x[:-lag, ...], x[lag:, ...]
                else:
                    continue
                corr[i, ...] = torch.sum(u * v, axis=[0, 1]) / (
                    torch.sqrt(
                        torch.sum(torch.square(u), axis=[0, 1]) *
                        torch.sum(torch.square(v), axis=[0, 1])
                    )
                )
            return corr
        else:
            raise NotImplementedError(f'Unknown method {method}.')

    @staticmethod
    def gauss_kde(x, lower, upper, n, bw=None):
        x = torch.ravel(x)
        grid = torch.linspace(lower, upper, n, device=x.device)
        if bw is None:
            bw = len(x)**(-1 / 5)
        norm_factor = (2 * np.pi)**0.5 * len(x) * bw
        return torch.sum(
            torch.exp(
                -0.5 * torch.square(
                    (x[:, None] - grid[None, :]) / bw
                )
            ),
            axis=0
        ) / norm_factor

    @abstractmethod
    def forward(self, input):
        '''Evaluate the input stochastic processes against the target statistic
        function.

        Parameters
        ----------
        input: tensor of shape (trajectory_length, n_batch, n_variables)
            The input trajectory as generated by an NN.
        '''


class ACFLoss(StatLoss):

    @classmethod
    def from_empirical_data(cls, data, lags, **options):
        '''Create target ACF from a number of empirically observed trajectories.

        Parameters
        ----------
        input: tensor of shape (trajectory_length, n_batch, n_variables)
            The empirically observed trajectories.
        options: keyword argument list
            To be forwarded to `__init__`.
        '''
        return cls(cls.acf(data, lags=lags), **options)

    def forward(self, input):
        '''
        Parameters
        ----------
        input: tensor of shape (trajectory_length, n_batch, n_variables)
            The input trajectory as generated by an NN.
        '''
        _input = self.acf(input, lags=len(self._target))
        return self._loss(_input, self._target)


class BruteForceACFLoss(StatLoss):

    @classmethod
    def from_empirical_data(cls, data, lags, **options):
        '''Create target ACF from a number of empirically observed trajectories.

        Parameters
        ----------
        input: tensor of shape (trajectory_length, n_batch, n_variables)
            The empirically observed trajectories.
        options: keyword argument list
            To be forwarded to `__init__`.
        '''
        return cls(cls.acf(data, lags=lags, method='bruteforce'), **options)

    def forward(self, input):
        '''
        Parameters
        ----------
        input: tensor of shape (trajectory_length, n_batch, n_variables)
            The input trajectory as generated by an NN.
        '''
        _input = self.acf(input, lags=len(self._target), method='bruteforce')
        return self._loss(_input, self._target)


class RandomBruteForceACFLoss(StatLoss):

    @classmethod
    def from_empirical_data(cls, data, lags, **options):
        '''Create target ACF from a number of empirically observed trajectories.

        Parameters
        ----------
        input: tensor of shape (trajectory_length, n_batch, n_variables)
            The empirically observed trajectories.
        options: keyword argument list
            To be forwarded to `__init__`.
        '''
        return cls(cls.acf(data, lags=lags, method='bruteforce'), **options)

    def forward(self, input):
        '''
        Parameters
        ----------
        input: tensor of shape (trajectory_length, n_batch, n_variables)
            The input trajectory as generated by an NN.
        '''
        lags = np.random.choice(len(self._target), self.sample_lags, False)
        _input = self.acf(input, lags=lags, method='bruteforce')
        return self._loss(_input, self._target[lags])


class DensityLoss(StatLoss):

    @classmethod
    def from_empirical_data(cls, data, lower, upper, n, **options):
        '''Create target PDF from a number of empirically observed trajectories.

        Parameters
        ----------
        input: tensor of any shape
            The empirically observed trajectories.
        options: keyword argument list
            To be forwarded to `__init__`.
        '''
        return cls(
            cls.gauss_kde(data, lower=lower, upper=upper, n=n),
            **options, lower=lower, upper=upper, n=n
        )

    def forward(self, input):
        '''
        Parameters
        ----------
        input: tensor of any shape
            The input trajectory as generated by an NN.
        '''
        _input = self.gauss_kde(
            input, lower=self.lower, upper=self.upper, n=self.n
        )
        return self._loss(_input, self._target)


def make_loss(stat, data, loss_type=['mse_loss', 'l1_loss'], **kwargs):
    '''
    Create a loss function.

    Parameters
    ----------
    stat: 'pdf' or 'acf[fft]' or 'acf[bruteforce]' or 'acf[randombrute]'
        Statistics to compute
    data: tensor
        Target statistics function or sample trajectories.
    loss_type: list
        Lower-levle loss functions to use.
    kwargs:
        additional arguments to pass to the loss function

    Returns
    -------
    loss: callable
        A loss function
    '''
    if stat == 'pdf':
        loss_cls = DensityLoss
    elif stat == 'acf[fft]':
        loss_cls = ACFLoss
    elif stat == 'acf[bruteforce]':
        loss_cls = BruteForceACFLoss
    elif stat == 'acf[randombrute]':
        loss_cls = RandomBruteForceACFLoss
    else:
        raise RuntimeError(f'Unknown stat {stat}.')

    def lower_level_loss(a, b):
        return torch.sum([getattr(F, ls)(a, b) for ls in loss_type])

    if len(data.shape) == 1:
        return loss_cls(
            data,
            loss=lower_level_loss,
            **kwargs
        )
    elif len(data.shape) == 3:
        return loss_cls.from_empirical_data(
            data,
            loss=lower_level_loss,
            **kwargs
        )
    else:
        raise RuntimeError('Unknown truth data format.')
